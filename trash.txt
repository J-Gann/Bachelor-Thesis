
In this scenario, the IMP system integrates only with the administration portal to extend the usage of identity related functionalities through the IMP client. The integration architecture contains one connector which integrates with the administration portal and communicates with IMP server and IMP client.

Through the integration, the user will be able to connect his OZG user profile with an IMP identity. As a result of this connection, the personal information of the user profile will be synchronized with the attributes of the IMP identity. The user will only be able to change personal information of his user profile through the IMP client. If the user has connected an IMP identity, starting an application will require authorization through the IMP client. However, starting and filling in the application will still be done through the web page of the administration portal and form server. After the user submitted the application through the form server, the user will be able to manage active applications through the IMP client.
The user will be able to send and receive messages of the user profile inbox through the inbox of the IMP client and combine the data wallet of the IMP client and user profile.

The integration provides an improved experience of the basic OZG use case through the IMP systems by making existing functionalities of the administration portal available through the IMP client. Especially the fact that the user wont have to manage the OZG user profile separately is an advantage for the user. Communicating with governmental institutions through the smartphone instead of a web page is also more convenient.

This integration scenario can be a first step by service providers to adopt an IMP system.

\paragraph{Linking IMP ID and OZG ID}

\begin{figure}[h]
\caption{Overview Connection}
    \centering
    \includegraphics[scale=0.25]{Diagrams/Integration 1/Connection/Overview.png}
\end{figure}


Before the IMP client can access services of the administration portal, the user has to be able to connect his IMP identity with the user profile. This is necessary for the integration architecture to enable bidirectional communication between OZG systems and IMP client regarding a user.

The administration portal hosts an additional web page where a logged in user can connect one IMP identity to his user profile. The IMP identity can be connected with the user profile through an IMP relationship between the administration portal and the IMP identity. The relationship includes the ID of the user profile in order for the relationship to be associated to a user profile. For a relationship to be established, a relationship template has to be created. This template is created by the IMP connector and stored on the IMP server. The template can be referenced through a template ID, created by the IMP server. The relationship template contains information about the administration portal, the reason for the relationship, attributes the IMP client is required to share as part of the relationship and additional metadata like the ID of the user profile or some legal information.
The reason for the relationship could be described like: "This relationship enables your identity to be connected with the user profile of the administration portal". The list of attributes required to be shared is based on the list of attributes stored in the OZG user profile. This will later enable the synchronization of attributes. The IMP identity is also required to share a JSON Web Token attribute. If this is the first time, the identity connects to a user profile, this attribute will not yet exist. The integration architecture will add it for means of authorization.
Based on the template ID, the connector creates a QR code which gets displayed on the web page for any IMP client to scan, retrieve the relationship template and issue a relationship request. The request contains information about the IMP identity and values for the requested attributes. The user gets notified of the connection request through an E-Mail which includes an URL. Visiting this URL will confirm the relationship request.

After confirmation, the IMP identity is connected with the administration portal through an IMP relationship which contains the ID of a user profile. The administration portal stores the IMP identity ID, the relationship ID and the user profile ID as an entry in a database.

The relationship can be cancelled through the IMP client or through the web page of the administration portal.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 1.png}
\end{figure}

The web server of the administration portal hosts an additional web page where a user can connect an IMP identity with his user profile. When a user tries to visit the web page, the browser sends a GET request to the web server and attaches a session ID as cookie. Based on the session ID, the web server can determine the user ID and the authentication state of the session. If the user is not authenticated, the server responds with a redirection to the login page. If the user is authenticated, the web server requests a QR code from the messaging system for connecting an IMP identity to the user ID of the session.

A messaging gateway is integrated into the run-time of the web server. It provides functions in an API for the server code to use for requesting services from the integration architecture or to notify it of events. If the server issues a function call from the API, the messaging gateway will send a corresponding message to the integration architecture. Depending on the API, the function will wait for a response before returning it or will accept a function as parameter and execute it upon receiving a response from the integration architecture. In order for the messaging gateway to match incoming replies to the issuing function calls, outgoing and incoming messages contain the same request ID.
After the authentication of the session is validated, the web server calls the API of the gateway to request a QR code for connecting an IMP identity to the user ID corresponding to the session. The web server passes the user ID as a parameter to the function.
The messaging gateway places a message which contains the user ID (UID) and the request ID (RID) on the "Connection QR Request" channel. Based on the request-reply pattern, the messaging gateway will expect a reply on the "Connection QR Reply" channel.

\textbf{Performance and Stability Considerations}: 

As the request for a QR code originates from the web browser of the user, a large amount of requests can be expected either due to a large amount of users or due to a few users issuing a large amount of requests. As the storage of channel adapters is limited, a large amount of requests could exhaust its capacity and lead to dropped messages. In order to handle request spikes, a message store could be attached before the "Connection QR Request" channel to act as a buffer. However, as the message requesting a QR code does not contain irreplaceable information and the user will probably not wait a long time until his web page loads, dropping messages is a reasonable solution.
To prevent the integration architecture from overloading, a stateful content-based router can be attached. He can keep track of all user IDs which issued a request and route the request of users to a dead letter channel if they exceeded the maximum amount of requests per minute. The messaging gateway of the web server consumes messages in the dead letter channel and returns an error to the function call corresponding to the request ID. Upon receiving the error, the web server can sent the user a suitable response.

\textbf{Failure Considerations}: 

In case of a complete failure of the integration architecture, all messages would be dropped and wont be able to recovered. This part of the system manages three types of messages, the incoming requests for QR codes on the "Connection QR Request" channel, the denied requests on the dead letter channel and the replies with QR codes on the "Connection QR Reply" channel.
If messages on the "Connection QR Request" channel get lost for example due to a system failure, no relationship template will be created and the web server will not receive a reply. It is not a problem, that no relationship template gets created as this will be done as soon as the next request message with the same user ID gets through. The problem of the web server not receiving a reply can be handled by the messaging gateway determining a timeout and returning an error to the function call. The web page could then sent a corresponding failure message to the user. The messages of the channel could be stored in a message store to be processed after the system failure, but the request is highly time dependent and to the user would not be waiting for the response.
If messages on the dead letter channel get lost, the messaging gateway does not get notified of a denied request message. Similar to the previously described situation, a timeout could return an error message to the function call.
If messages on the "Connection QR Reply" channel get lost, the web server will not receive a reply although a relationship template exists and the QR code was retrieved. As the created relationship template and the QR code are stored in a database, a following request will be able to retrieve the result quickly. Similar to the previously described situation, a the messaging gateway could return an error message to the function call due to a timeout.

\textbf{Administration Considerations}: 

In order for administrators to verify that all requests issued to the integration architecture succeed and to monitor the processing time of requests, a control bus can monitor the "Connection QR Request" channel and the "Connection QR Reply" channel. To be notified of malicious request activities, the control bus can also monitor the dead letter channel.

\textbf{Future Proofing Considerations}

In the future, the format in which the web server expects the data to be returned might change. It could for example request the template ID not to be delivered as QR code but as barcode or as an integer or a string. One possibility would be for the API of the messaging gateway to change and modify the returned results accordingly. In order to decouple the messaging gateway from the requested data format, a message translator can be included. If the web server requires a new data format, the message translator can change the content of the messages accordingly.
It could also happen, that in the future, the web server passes the user ID in a different format. In order for the same user ID with different formats to not be treated as different users, a message translator can be included who maps the user ID to a canonical data format.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 2.png}
\end{figure}

Until now, the integration architecture is able to receive requests for QR codes for connecting IMP identities to user profiles on the "Connection QR Request" channel. The requests originate from authenticated users and are filtered to prevent an overload.

The integration architecture now has to return a relationship template in form of a QR code to the web server. As the name suggests, the relationship template is the basis for creating a relationship request. One template can therefore be used multiple times. Therefore, in order to save resources, QR codes for connecting IMP identities and user profiles should be reused. However, it still has to be possible to use new relationship templates, as the required content of future relationships might change. It could for example happen, that additional attributes are required to be shared by the IMP identity or that a user agreement attached to the relationship metadata changed.

The messaging architecture contains a database which is responsible for storing all QR codes and the corresponding user IDs. Upon receiving a message on the "Connection Qr Reply" channel, the integration architecture therefore first checks if a QR code is stored in the database for the specified user ID. If this is the case, the corresponding QR code is sent back as reply to the web server. If no QR code can be found, the user corresponding to the UID did not yet connect to an IMP identity and a relationship template has to be created.
In order to check if a QR code exists, the messages from the "Connection QR Request" channel are consumed by a content based router who is connected with the QR code database. Depending on the existence of a QR code, the router sends the message in different directions. In one direction the existing QR code will be delivered to the web server, in the other direction, a new relationship template will be created.

\textbf{Performance and Stability Considerations}: 

It has to be made sure, that for each user ID, only one message is sent down the path of creating a new relationship template at the same time to prevent multiple creations of the same relationship template. Therefore, besides the existing QR codes, a list of user IDs is maintained. Each time the content based router sends a message to create a new template, he stores the respective user ID in the database. A selective consumer is inserted before the content-based router to only forward messages which contain a user ID not stored in the database. Once the database storing the QR codes adds a new entry, it notifies the other database to remove the corresponding user ID. The messages which were hold back are now routed to the path of existing QR codes. 

\textbf{Failure Considerations}: 

One important requirement of this system is, that for each user ID a QR code will eventually be added to the database. If a message which was routed to the path of creating a new template gets lost or the creation of the QR code fails, no message with the same user ID will be let through by the selective consumer. Therefore, along with the user ID, a timestamp should be saved in the database to remove all user IDs older than a few minutes. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 3.png}
\end{figure}

So far, the integration architecture is able to route a request for a QR code to either use an existing one or create a new template. To use an existing QR code, the message is routed to a content enricher which retrieves the QR code corresponding to the user ID from the database and attaches it to the message. A content filter removes the user ID afterwards and publishes the message to the "Connection QR Reply" channel.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 4.png}
\end{figure}

So far, the integration architecture is able to send existing QR codes to the web server. In order to create new relationship templates, the content-based router sends the message to a content enricher. This content enricher accesses a database storing configuration parameters (Conf) for creation of relationship templates and attaches it to the message, then sends the message to the "Create Relationship Template" channel. In order for the administration to change the configuration, the content enricher also adds the version number of the configuration (VER) to the message.

\textbf{Administration Considerations}: 

To enable the administration to change the relationship template for new relationship requests, a control bus is attached to the content-based router, the content enricher, the user ID database and the QR code database. The control bus first momentarily halts the router, changes the configuration stored at the content enricher, increments its stored version number, removes all data from both databases then activates the router again. Deletion of the databases enables the population of the database with new QR codes. Request messages which were issued before halting the router but did not yet result in the storage of the corresponding QR code will be deleted upon being received by the QR code database. The database will refuse to store QR codes with a version number lower than the current increment.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 5.png}
\end{figure}

The message including the configuration for creating a relationship template now has to be delivered to the connector. The connector contains a messaging gateway which can receive a message containing a configuration on the "Template Request Connector" channel and publish QR codes of all created relationship templates on the "Template Reply Connector" channel. The connector creates a relationship template based on the configuration attached to the message. The relationship template is stored on the IMP server but can be retrieved through a template ID. The connector exports the ID as a QR code and publishes it on the "Template Reply Connector" channel.

\textbf{Future Proofing Considerations}:

In order for the solution to be future proof, the service of the connector should be usable from any place in the integration architecture. A smart proxy is therefore introduced, which consumes messages that were published on the "Template Request" channel. The messages on this channel have to specify a channel where they expect the smart proxy to send the reply. The specified return address in this case is the "New Connection Template Reply" channel, as the template created in this case is for connecting an IMP identity to a user profile. The smart proxy requires request ID (RID) in order to correlate replies coming from the connector to the specified return address. As the messages in this case already contain a request ID no new one has to be added. It is expected, that all request IDs independent of where they were created are unique. As the messaging gateway expects a message to only contain a configuration and a correlation identifier, a content filter is attached before the "Template Request" channel to remove all attributes besides the request ID and the configuration and save the message in a message store. After receiving the reply from the smart proxy on the "New Connection Template Reply" channel, a content enricher adds the removed attributes to the message based on the request ID. The configuration and return address however are obsolete and therefore not added again. The message is then published to the "New Connection Template" channel.

The IMP connector includes a messaging gateway which enables services of the connector to be used through messaging. The messaging gateway of the connector should be decoupled from the integration architecture as much as possible. It should only be able to receive a message trough a request channel, derive the requested service from the used channel and publish the result on a reply channel corresponding to the request channel. For each request reply channel,the connector is connected to, a smart proxy is attached, which 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 6.png}
\end{figure}

So far, the integration architecture is able to create new relationship templates if necessary. The resulting QR code now has to be stored in the database and delivered to the web server. In order to deliver the message to the web server, a content filter removes the user ID from the message and publishes it to the "Connection QR Reply" channel, where the messaging gateway of the web server waits for replies.
In order to store the QR code in the database, the message is sent to another content filter which removes the request ID from the message and sends it to the database for storage. A message filter is inserted before the database to remove all messages which contain a version number lower than the current increment.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 7.png}
\end{figure}


Now that the web server retrieved the QR code, he sends the web page including the code to the user. The IMP client of the user scans the QR code on the web page and extracts the template ID. Based on this template ID, the client retrieves the relationship template from the IMP server and displays it on the screen. The user is asked if he wants to send a relationship request to the administration portal. The interface displays information about the administration portal, personal information which will be shared from the portal and from the user as part of the relationship and additional metadata information like user agreements. If the user accepts, the client creates a relationship request and sends it to the IMP server, which stores the request and forwards a request ID to the connector.
Upon receiving the request ID, the connector retrieves the corresponding request from the IMP server, publishes a message containing the relationship request (REQ) and the request ID (RID) to the "Relationship Request" channel and based on the request-reply pattern expects a message containing a response (RESP) and the request ID (RID) on the "Relationship Response" channel.
A message filter lets only messages through which contain a relationship request which contains a user ID as metadata. This makes sure, that in the following, only relationship requests are processed which result in the connection of a IMP identity with a user profile. The messages from the message filter are consumed by the connection process manager. The process manager will create a new process for each relationship request. He is able to keep track of the current progress of the request and he can initiate new processing steps.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 8.png}
\end{figure}

Messages on the "Relationship Request" channel are consumed by a content-based message router. The router performs validation steps on the relationship requests. It can for example check, if the UID exists and if the corresponding user already has a IMP connected. It can also for example check if the name shared by the IMP identity is the same as in the user profile. If the validation fails, the message is sent to a content enricher who attaches the corresponding negative response to the message. If the validation succeeds, a later described user confirmation process either accepts or reclines the request. In both cases, a message containing the response is published on the "Relationship Response" channel. The connector reads the response from the channel and either confirms the relationship or cancels the request. A content enricher also subscribes to the "Relationship Response" channel and together with a content filter creates a message which contains a user ID and an email body, which depending on the response attribute either informs the user of a accepted or of a denied connection. The message is consumed by the messaging adapter of the web server which sends the mail to the address corresponding to the user ID.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 9.png}
\end{figure}

If the content-based router validates the relationship request, the message is sent to a content enricher, who generates a token and attaches it to the message. The message including the generated token is stored in a database. The message is sent to another content enricher, who adds the body of an E-Mail. The mail informs the user about a requested connection of an IMP identity. The mail also contains an URL to an additional web page the server hosts. The URL contains the previously generated token. If the user tries to open the URL, the GET request to the web server therefore submits the token. If the web server receives the GET request, he sends a message to the "Relationship User Confirmation" channel, containing the received token. A content enricher consumes this message and searches for the token in the database. If he finds an entry, he retrieves the stored message, adds a positive response to the message and publishes it on the "Relationship Response" channel. The message stored in the database is deleted afterwards.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{Diagrams/Integration 1/Connection/Messaging 10.png}
\end{figure}

The connector sends a relationship request response to the IMP server. If the response was negative, the server notifies the IMP client. If the response was positive, the IMP server stores the established relationship and notifies IMP client and connector with a relationship ID. Upon receiving the relationship ID, the connector retrieves the relationship and sends a message to the "New Relationship" channel. Through a messaging gateway, a database consumes the message and adds an entry to the database containing the relationship ID, the user ID and the IMP identity ID. Afterwards, the database publishes a message to the "Connection Finished" channel containing the user ID.

\paragraph{Authorisation}

After the user connected an IMP identity to his user profile, the IMP identity has to be authorized to access resources of the OZG systems. The OZG system architecture uses JSON Web Tokens for authorization management. In order to minimize integration complexity, the IMP identity also uses JWT for authorization. To enable the IMP identity to us a JSON Web Token, the integration system will have to create the token, store it somewhere, enable the IMP client to make use of it and enable the OZG system architecture to associate the JSON Web Token with an IMP identity.
The web server is able to request a JWT from the user profile component, which after a successful authentication of the user will transmit the requested token. The token can then be stored as attribute of the IMP identity.
Every time, the integration architecture receives a request from the IMP client, it can retrieve the JWT corresponding to the IMP identity and attach it to a request to the web server. 















\paragraph{Personal Information}

One of the goals of an IMP system is to enable the user to only manage his identity in one place while all other service providers rely on the attributes of the identity. As in this scenario however, the OZG system does not rely on attributes of the IMP system but enables it to manage personal information stored in the user profile. Some synchronisation mechanism can therefore operate.

\begin{center}
    \includegraphics[scale=0.3]{Diagrams/Integration 1/Personal Information/Overview.png}
\end{center}

While configuring the authorisation of the IMP identity on the previously described website, the user can determine if the IMP identity is allowed to manage personal information stored in the user profile. If the user approves, the JSON web Token stored as attribute of the identity is authorized to update, delete and read attributes of the user profile. As the user profile determines which attributes exist, no attributes can be added.

If an attribute of an identity changes, the IMP client notifies all relationships. When the connector receives this notification, he reads all shared attributes and requests the administration portal to update the same attributes in the user profile. As the naming and meaning of attributes can differentiate between IMP systems and OZG systems, the attributes have to be mapped to each other. A simple solution would be a table, created by an administrator, which maps each attribute from the IMP system to an attribute of the OZG system.

\paragraph{Inbox}

Both IMP Client and the administration portal provide an inbox functionality. If an IMP identity has established a relationship with the administration portal, they can exchange messages through the connector as part of this relationship.

In order to notify the user of a new message to the user profile, the administration portal can send the same message through the relationship associated with this user.
The user can, however, only send messages to the administration portal and not to for example institutions.

\paragraph{Data Wallet}



























































\subsection{Create User Profile}

The first step of the basic OZG use case is the creation of a user profile through the web page of the administration portal.

Creation and management of multiple user profiles quickly becomes a burden for users. If all service providers would switch to using only identities provided by an IMP solution, users would only have to manage one digital identity. However performing this change is no simple task for a service provider. An abrupt change of the system architecture can lead to many problems like extended periods of down times. This integration architecture therefore focuses on a simplified initial integration of IMP identities where OZG user profiles can still be used to access OZG services.

It would be possible to integrate the IMP identity as an alternative to the user profile. The user could then use OZG services either by creating an OZG user profile or by providing an IMP identity. Another option would be to enable a connection of an existing IMP identity and an existing OZG user profile. The user would then have to create a user profile in order to access OZG services but could connect an IMP identity for improved identity management. The benefit of using the IMP identity as an alternative is, that the user has better control over his personal information, as the attributes of the identity are not stored by the OZG system architecture but the IMP solution. OZG systems would have to request personal information from the IMP identity while providing a reason for doing so. After the user updates attributes of its IMP identity, the OZG systems would automatically use the most recent values when requesting access to personal information of the IMP identity. However, this form of integration is already pretty advanced and would require invasive integration in order for the administration portal to add an additional process for executing the basic use case with the IMP identity instead of the user profile. As the focus of this integration architecture is non invasiveness, the connection of IMP identity and user profile is preferred.

The IMP solution provides a service for establishing a connection between entities. It is called an IMP relationship. Through a relationship, two entities can identify each other, assume authentication of the other party and can securely communicate and share attributes of their IMP identities. To utilize an IMP relationship between the administration portal and the IMP identity as connection between user profile and IMP identity, the relationship has to contain identification of the user profile in form of for example a user ID. The administration portal would then be able to map relationships along with the IMP identity ID to user profiles.

\subsection{Attribute Synchronization}

The goal of the connection of IMP identity and OZG user profile is to enable management of personal information through the IMP client. Attributes stored as part of the IMP identity and attributes stored as part of the user profile have to be manageable through the IMP client.

One option would be for the IMP client to overwrite all attributes of the OZG user profile with those stored in the IMP identity and update values in the user profile as soon as an attribute of the IMP identity changes. This would require the user profile management web page of the administration portal to be locked for profiles with a connected IMP identity. Another option would be to enable the user to manage attributes of IMP identity and user profile separately through the IMP client.

The benefit of the first option is, that the user only has to manage attributes for his IMP identity and the user profile will be updated automatically. However, this would require the user to always share the most current personal information with the OZG systems. Depending on the service provider, updates of attributes might not be possible in every case or would require additional actions by the service provider. If the user for example changes the birth date of its IMP identity, the OZG system might not want to approve this change immediately. Another option would be for the user to manage IMP identity and user profile separately. Changes of the OZG user profile can then happen on a request reply basis. The user would also be able to manage its OZG user profile through the web page of the administration portal and request attribute changes from there. The disadvantage of this option is, that the management of personal information is more complicated than the first option. Through attribute management tools on the IMP client, the experience can be improved.

As the second option provides necessary features, which the first option does not have, it is preferred.

The management of both IMP identity attributes and attributes of the OZG user profile can be done as part of the relationship established for their connection. As part of the connection, IMP identity and administration portal share attributes. The user profile can be determined to store the exact same values as shared by the IMP identity as part of this relationship. Therefore, in order to change attributes of the user profile, the value of the shared attributes has to change. This can be done through a request-reply process. One party requests the change of a shared attribute, which will only be done if the other party accepts. This enables the user to manage the OZG user profile through the IMP client by requesting a change for attributes shared as part of a relationship. The user could also manage his user profile through the web page of the administration portal, resulting in a request form the administration portal to change shared attributes of the relationship.

\subsection{Login to a User Profile}

The second step of the basic OZG use case is to login to a user profile on the web page of the administration portal to access OZG services. As previously described, the integration architecture does not replace the OZG user profile. The user is therefore still able to login to his user profile on the administration portal and take advantage of all OZG services. The IMP system can however provide an additional way to access OZG services through the IMP client. One possibility was already introduced: the management of personal information.

In order for the administration portal to perform actions on behalf of a user, it has to verify, that the request is valid. Through the web page, this is often done by establishing a browser session, through a cookie and after the authentication process, updating the authentication status of the session. When the web server receives a request from a authenticated session, it can use a JSON Web Token, created during the registration process to access resources of other system components. This process is necessary because any person can send requests to the web server and possibly pretend to be a different user. In contrast to the web browser, requests coming through the IMP system can be assumed to be valid and therefore originate from the correct IMP identity and user. Therefore it is not necessary for the user to authenticate for the OZG system when using an IMP identity. As the IMP client is an app installed on the device of the user, it might even be possible to completely remove user authentication when accessing the client as most users secure their phones through a lock pattern already.

\subsection{Application for Administrative Service}
The third step is selection of an administrative service through the web page of the administration portal. This service is not directly related to identity management and will therefore not be provided by the IMP client.
The steps four to eight are not integrated by the IMP solution as this would require invasive interaction with components other than the administration portal.

As a result of that, most of the steps necessary for applying for an administrative service remain to be done through the web page of the administration portal with a logged in user profile. The next integration architecture will present a solution where most of the steps will be done through the IMP systems.

\subsection{Communication}

The ninth step of the basic OZG use case is to communicate with responsible institutions. As both the user profile and the IMP identity provide an inbox, the IMP client can be used to send and receive messages through the inbox of the OZG user profile.

The messages related to a OZG user profile can be exchanged as part of the relationship between the administration portal and the IMP identity. Messages received by the user profile can be forwarded by the administration portal to the inbox of the IMP identity. Sending messages from the IMP client to institutions however is not possible, as the IMP client does not know the address of the institution responsible for an application. However, if the IMP client already received a message from an institution, it can enable the user to respond.



































































\subsection{Create User Profile}

\begin{figure}[h]
    \centering
    \caption{Overview Connection}
    \includegraphics[scale=0.2]{Diagrams/Integration Architecture 1/Messaging/Connection/Technological Integration Connection.png}
\end{figure}

In order for an IMP identity to request a relationship with the administration portal, the portal has to provide a relationship template to the IMP client of the user. The template can be made accessible to the IMP client trough a new web page which displays the template ID as QR code if the user is logged in. Each time a logged in user requests the web page, the web server requests the IMP connector to create a relationship template.

The IMP connector provides an API for creation of relationship templates as part of its REST interface. Through a HTTP POST call, the web server transmits the appropriate request to the connector and receives the template as response. The web page of the administration portal can then render the template as a QR code on the web page.

\begin{figure}[h]
    \centering
    \caption{Relationship Template}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Relationship Template REST.png}
\end{figure}

This is one example, where the OZG system could use the REST interface for integration with the IMP system. However, messaging can improve the integration solution to be more maintainable, stable and scalable and will be the preferred option in following scenarios. Using messaging, the web server can publish a message containing the request for a new relationship template on a "Relationship Template Request" channel, where the connector receives it, creates the template and publishes a reply message containing the template ID on the "Relationship Template Reply" channel.

\begin{figure}[h]
    \centering
    \caption{Relationship Template Messaging}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Relationship Template Messaging.png}
\end{figure}

It could happen, that in future, the API of the connector changes. If the web server integrated the connector through its REST interface, this would require the request code of the web server to be changed. If messaging is used, messages leaving the "Relationship Template Request" channel could be mapped to the new API signature through an additional messaging component called message translator. This is an example for how a messaging can improve maintainability of an integration architecture.

\begin{figure}[h]
    \centering
    \caption{Relationship Template Improved Messaging}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Relationship Template Messaging Improved.png}
\end{figure}


When the user is presented with the web page containing the QR code, the user can scan it with its IMP client. Based on the template ID, the client retrieves the template from the IMP server and displays it for the user. If the user accepts the template, the client sends a relationship request to the IMP server, who forwards it to the corresponding connector.

Upon receiving the request, the connector has to notify the administration portal of an incoming relationship request. If the web server does not provide an HTTP endpoint for communicating with the connector, it won't be able to receive a notification about the arrival of a new relationship request. The server would have to regularly request a status update which is not efficient. Using messaging, the connector can publish the content of the relationship request to a "Relationship Request" channel where the subscribed administration portal will be notified. The administration portal can process the relationship request and publish a message containing a response on the "Relationship Response" channel, where the connector will be notified. Through the IMP server, the response server is routed to the IMP client and the relationship is established.
In order to map relationships to user profiles, the administration portal manages a database which contains entries consisting of IMP identity ID, relationship ID and user profile ID.

\begin{figure}[h]
    \centering
    \caption{Relationship Request}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Relationship Request.png}
\end{figure}

\subsection{Attribute Synchronization}

As administration portal and IMP identity established a relationship, the connector can be excluded from the diagram for better visualisation. Behind the scenes, all interactions between administration portal and IMP client still go through connector and IMP server.

If the user requests the change of a shared attribute through the IMP client, it sends an attribute change request to the administration portal by publishing a message on the "Inbound Attribute Change Request" channel. After the administration portal decides to accept the request, it can publish a message to the "Outbound Attribute Change Response" channel. This message will on one hand be received by the IMP client and on the other hand result in an update of the user profile. 

\begin{figure}[h]
    \centering
    \caption{Attribute Change Inbound}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Attribute Change IMP Client.png}
\end{figure}

If the user requests the change of a shared attribute through the web page of the administration portal, the web server sends an attribute change request to the "Outbound Attribute Change Request" channel which is received by the IMP client. If the user accepts the request, the client publishes a message on the "Inbound Attribute Change Response" channel where it results in an update of the user profile.

\begin{figure}[h]
    \centering
    \caption{Attribute Change Outbound}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Attribute Change Web Page.png}
\end{figure}

\subsection{Login to a User Profile}

The administration portal receives a request from the IMP client through a "Request" channel. Through the connection database created in 4.2.2, the administration portal finds the corresponding user ID. Through a JWT database, where all JWT tokens are stored for the user profiles, the administration portal retrieves the JWT corresponding to the user ID. The administration portal can then route the request on the "Request" channel and attach the JWT.

\begin{figure}[h]
    \centering
    \caption{Authentication}
    \includegraphics[scale=0.3]{Diagrams/Integration Architecture 1/Overview/Login.png}
\end{figure}

\subsection{Communication}


































The first step of onboarding a new user was to create and display the relationship template. A messaging adapter is attached to the web server of the administration portal. The adapter presents an API for retrieving relationship templates for onboarding towards the coding of the web server. The code of the web server is manually modified to use the API to retrieve the template before sending the profile creation web page to the user. The messaging adapter can publish requests on the "Onboarding Template Request" channel and receive responses on the "Onboarding Template Response" Channel. The adapter defines a format for the message containing the request and expects a certain format of the response message. The message the adapter publishes on the "Onboarding Template Request" channel contains a request ID and template metadata. The request ID is a unique number, which will be included in the response. Through this ID, the adapter can return the response to the issuer of the request message. The template metadata are dynamically created attributes of the web server which should be included in the relationship template. Based on this metadata, the web server can personalize the processing of the template and the eventually resulting relationship request. In this case, the web server includes the session ID of the user as metadata to associate template and relationship request with the session. This enables the web server to send status updates to the user through the web page.

Requests on the "Onboarding Template Request" channel are processed by the "Onboarding Template" Module.

The module stores the configuration of the onboarding template. The configuration defines the content of the template like title, requested attributes and more for the onboarding scenario.

The request message is consumed by the "Config Enricher" who adds the stored configuration as a new entry to the message.
The template configuration lists attributes which are required by the user in order to request the relationship. Because the relationship based on this template will eventually be used to create a user profile, all attributes required to create a user profile will have to be requested by the template. As the OZG user profile and the IMP identity might not share the same definitions for attributes, the attribute names used by OZG user profile component have to be manually mapped to those used by the IMP system. The attribute names the IMP system understands are included in the template.
To create a suitable configuration object, the connector can understand, the message is consumed by the "Config Object Creator" component. This component incorporates the template metadata included in the original request message into the template configuration and structures the configuration for example as a JSON object. This is done to decouple the data representation of the messaging adapters. The adapter of the web server might use XML and the adapter of the connector might use JSON.

A channel adapter is also attached to the connector. It is able to transform messages sent to a specific set of channels to a suitable REST request. Responses are then published to a specific set of response channels. For each possible REST request, one request and reply channel exists.

In this case, the message containing the template configuration is published on the "Template Request" channel. The messaging adapter sends a REST request to the connector, requesting a new relationship template along with the configuration. The adapter then publishes the response along with the request ID on the "Template Response" channel.

The "Template Request" and "Template Response" channel can be used by any number of messaging modules, therefore it is necessary for the "Onboarding Template" module to only process template responses it is responsible for. Therefore a "Onboarding Template Filter" component consumes all messages on the "Template Response" channel but only publishes templates of the onboarding type to the "Onboarding Template Response" channel. Before publishing, a "Response Formatting" Component maps the data format of the message so that the adapter of the web server understands it.

The web server consumes the response and based on the session ID stored in the template knows which user to send it.

















The first step of the basic OZG use case is the creation of a user profile through the web page of the administration portal. This is not necessary any more, as user profiles are replaced by IMP identities. The user will only have to create an IMP identity.

The second step of the basic OZG use case is to login to a user profile on the web page of the administration portal. As user profiles get replaced by IMP identities, the IMP client can be used to access OZG services. The IMP client does not require authentication, as it is installed on the smart phone of the user. The user can secure his smartphone through for example biometric authentication.

The third step of the basic OZG use case is to select an administrative service which is still done through the web page of the administration portal.

The fourth step of the basic OZG use case is to fill in the application. The application is not started by the user filling in a form on the form server and submitting the result to the administration portal any more, but by requesting a relationship with the institution responsible for processing a selected application.

The web page of the administration portal displaying a selected administrative service does not contain an integration with a form server any more. Instead it displays the QR code for a relationship template provided by the institution responsible for processing the application.

For each administrative service, the institution is responsible for processing, it issues a HTTP POST request to the institution connector requesting the creation of a relationship template. The connector responds to the institution with the template IDs.

In order for the administration portal to display the correct relationship template, he requests the user to manually enter his home address. After the administration portal determined the responsible institution, he retrieves the correct template ID and displays it to the user as QR code.

If the user scans the QR code with his IMP client, the client retrieves the relationship template corresponding to the template ID of the QR code and display it. The relationship template contains a description of the selected administrative service as reason for the relationship. The template also requests the IMP identity to share several attributes, which the institution requires in order to process the application. This replaces the functionalities of the form server.

The fifth step of the basic OZG use case is to submit the application. After the user accepts the relationship template, the client sends a relationship request to the institution which created the template along with the shared attributes. The institution can accept the request and start processing the application. The IMP identity in this case has to share personal information only with the specific institution responsible for processing the application.

The sixth and seventh steps of the basic use case are no longer necessary as the application is properly delivered to the institution as result of the fifth step.

The eighth step of the basic OZG use case is the management of active applications. As each application is represented by a relationship between an institution and an IMP identity, the application can be managed by requesting a termination of the relationship and sharing the status of the relationship as part of an attribute of the institution. Termination of the relationship after approval of both parties, also prohibits the institution from further usage of personal information of the IMP identity.

The ninth step of the basic OZG use case is the communication between user profile and institutions responsible for active applications. As an active relationship is represented by a relationship, the two parties can directly communicate through the relationship.









































\subsection{User Perspective}

\begin{itemize}
    \item The user wants one service where he can manage all personal information 
    
    \item The user does not want to manage multiple user profiles
    
    \item The user wants all service providers to be able to use the personal information of the service
    
    \item The user wants service providers to always use the most recent state of his personal information
    
    \item The user wants to be able to share and retract personal information, service providers have access to
    
    \item The user wants to restrict access to personal information as much as possible
    
    \item The user wants information about the service provider he is about to share information with
    
    \item The user wants to know the reason each time a service provider wants to process his personal information
    
\end{itemize}

\subsection{Service Provider Perspective}

The service provider is assumed to have an existing system architecture containing systems for management of user profiles. This section describes requirements of a service provider regarding the service for managing user data.


\begin{itemize}
    
    \item The service provider wants a good user experience -> see all user requirements above
    
    \item The service provider wants to access personal information necessary for processing user requests
    
    \item The service provider wants to change, add or delete personal information
    
    \item The service provider wants to communicate with users
    
    \item The service provider wants to the service to guarantee secure interaction with users
    
    \item The service provider wants the system to keep a record of interactions with users and be able to verify the validity of the record
    
    \item The service provider wants to inform users about legal regulations like privacy protection measurements
    
    \item The service provider wants minimal integration effort and cost
    
    \item The service provider wants to be able to quickly integrate parts of the service with optional future upgrades
    
    \item The service provider wants the integrated solution to be scalable, maintainable and stable

\end{itemize}